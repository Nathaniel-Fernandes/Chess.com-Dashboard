[{"C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\index.js":"1","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\App.js":"2","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\Initialize.js":"3","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\State\\store.js":"4","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\urls.js":"5","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\helpers.js":"6","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\components\\LoadForm.js":"7","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\Analyze.js":"8","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\AnalyzeHelpers.js":"9","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\AnalysisMetrics.js":"10","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\RecordPrototypes.js":"11","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\fen.js":"12","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\Charts\\CAPS.js":"13"},{"size":235,"mtime":1607466474208,"results":"14","hashOfConfig":"15"},{"size":1317,"mtime":1607904914387,"results":"16","hashOfConfig":"15"},{"size":3497,"mtime":1607904651761,"results":"17","hashOfConfig":"15"},{"size":3036,"mtime":1607905645819,"results":"18","hashOfConfig":"15"},{"size":579,"mtime":1607554564394,"results":"19","hashOfConfig":"15"},{"size":1935,"mtime":1607664211548,"results":"20","hashOfConfig":"15"},{"size":450,"mtime":1607486841061,"results":"21","hashOfConfig":"15"},{"size":1805,"mtime":1607905512138,"results":"22","hashOfConfig":"15"},{"size":9000,"mtime":1607822008194,"results":"23","hashOfConfig":"15"},{"size":11252,"mtime":1607903870266,"results":"24","hashOfConfig":"15"},{"size":3299,"mtime":1607889548270,"results":"25","hashOfConfig":"15"},{"size":692,"mtime":1607886954037,"results":"26","hashOfConfig":"15"},{"size":481,"mtime":1607903633564,"results":"27","hashOfConfig":"15"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"30","usedDeprecatedRules":"31"},"gju65z",{"filePath":"32","messages":"33","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"34","usedDeprecatedRules":"31"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37","usedDeprecatedRules":"31"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"44","usedDeprecatedRules":"31"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"31"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"50","messages":"51","errorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52","usedDeprecatedRules":"31"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55","usedDeprecatedRules":"31"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},"C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\index.js",["62"],"import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport { Provider } from 'jotai'\n\n\nReactDOM.render(\n  <React.StrictMode>\n      <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n\n",["63","64"],"C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\App.js",["65","66"],"import React, { useEffect, useState } from 'react';\nimport { initializeState } from \"./BusinessLogic/Initialize\";\nimport LoadForm from './components/LoadForm';\nimport { store } from './State/store';\nimport CAPS from './Charts/CAPS'\n\nfunction App() {\n\t// useEffect(() => {\n\t// \t// load initial state\n\t// \tinitializeState();\n\n\t// }, [])\n\tconst [initialized, setInitialized] = useState(false)\n\tconst [popupBlocker, setPopupBlocker] = useState(false);\n\t\n\tconst archive = store(state => state.GameArchive);\n\tconst gameID_arr = store(state => state.Games);\n\n\tuseEffect(() => {\n\t\tconst t = window.open('','_blank');\n\t\tif(t === null || t === undefined || !t) {\n\t\t\tsetPopupBlocker(true);\n\t\t\treturn;\n\t\t}\n\t\tt.close();\n\t\t// setTimeout()\n\t},[])\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        \n      </header>\n\n\t\t{\n\t\t\t(popupBlocker) ? \"Please disable your popup blocker\" : ''\n\t\t}\n\t\t{\n\t\t\t(!initialized) ? <button onClick={() => {\n\t\t\t\tinitializeState();\n\t\t\t\tconsole.log(\"initialization\")\n\t\t\t}}>Click to Start</button> : ''\n\t\t}\n\t\t\n\n\t\t<p>{(store.getState().loading) ? \"Loading\" : \"View\"}</p>\n\t\t<ol>\n\t\t\t{archive.map(\n\t\t\t\t(e) => <li>{e}</li>\n\t\t\t)}\n\t\t</ol>\n\t\t<br />\n\t\t<ol>\n\t\t\t{gameID_arr.map(\n\t\t\t\t(e, key) => <li key={key}>{e.id}</li>\n\t\t\t)}\n\t\t</ol>\n\n\t\t <CAPS />\n    </div>\n  );\n}\n\nexport default App;\n","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\Initialize.js",["67","68"],"import { store } from '../State/store';\r\nimport { ArchiveURL } from './urls';\r\nimport { \r\n\tColorfromGame, \r\n\tCreateURL, \r\n\tGetURL, \r\n\tIDfromURL, \r\n\tResultFromGame, \r\n\tTimeControlFromGame, \r\n\tTimeClassFromGame,\r\n\tDateFromGame } from './helpers';\r\nimport { Analyze, AnalyzeGame } from '../BusinessLogic/Analyze';\r\n\r\nexport const timeout = (ms = 5000) => { \r\n\treturn new Promise((resolve) => setTimeout(resolve, ms));\r\n}\r\n\r\nexport const initializeState = () => {\r\n\t// check if less then 100 games\r\n\tif (store.getState().Games.length < 100) {\r\n\t\tconsole.log(\"hellow?\")\r\n\r\n        GetURL(CreateURL(ArchiveURL, store.getState().UserName))\r\n\t\t\t.then((res, err) => {\r\n\t\t\t\t\t// primitive error handling\r\n\t\t\t\t\tif(err) { console.warn(err); return; }\r\n\t\t\t\t\telse if(res.data.status === 404) return;\r\n\r\n\t\t\t\t\tstore.getState().setGameArchives(res.data.archives)\t\t// think a synchronous call to update Archives\r\n\t\t\t\t\tconsole.log(store.getState().GameArchive)\t\t\t\t// prints out updated state\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn GameIDfromArchive();\r\n\t\t\t})\r\n\t\t\t.then(async (res) => {\r\n\r\n\t\t\t\tfor(let i = 0; i < 2; i++) {\r\n\t\t\t\t\tAnalyzeGame(store.getState().Games[i]);\r\n\t\t\t\t\tawait timeout(1000);\r\n\t\t\t\t}\r\n\t\t\t}).then(() => {\r\n\t\t\t\tconst tacticsObj = {\r\n\t\t\t\t\tfork: store.getState().fork,\r\n\t\t\t\t\tmate: store.getState().mate,\r\n\t\t\t\t\thanging: store.getState().hanging,\r\n\t\t\t\t\trelativePin: store.getState().relativePin,\r\n\t\t\t\t\tabsolutePin: store.getState().absolutePin,\r\n\t\t\t\t\ttrapped: store.getState().trapped,\r\n\t\t\t\t\tunderdefended: store.getState().underdefended,\r\n\t\t\t\t\twinningExchange: store.getState().winningExchange,\r\n\t\t\t\t\tskewer: store.getState().skewer,\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconsole.log(JSON.stringify(tacticsObj, null, '  '))\r\n\t\t\t})\r\n\t}\r\n}\r\n\r\n/**\r\n * @description Adds the GameIDs to GameID array from the archive\r\n * @returns {void} A promise  \r\n * @todo don't hardcode # of games\r\n */\r\nconst GameIDfromArchive = async () => {\r\n\t\tconsole.log(\"Current Store: \", store.getState())\r\n\t\tlet archives = store.getState().GameArchive;\r\n\t\tlet i = archives.length - 1;\r\n\t\tlet gamenum = store.getState().Games.length;\r\n\t\tlet games;\r\n\r\n\t\t// TESTS\r\n\t\t// 1. <100 games\r\n\t\t// 2. >100 games\r\n\t\t// 3. multiple archives\r\n\t\t// (async _ => {\r\n\t\t\twhile(archives[i] && i >= 0 && gamenum <= 100) { \r\n\t\t\t\tconsole.log(\"GM top loop: \", gamenum)\t\r\n\t\t\t\t\r\n\t\t\t\tconsole.log(archives[i])\r\n\r\n\t\t\t\tawait GetURL(archives[i])\r\n\t\t\t\t\t.then(res => {\r\n\t\t\t\t\t\t//  console.log(res.data)\r\n\t\t\t\t\t\tgames = res.data.games\r\n\r\n\t\t\t\t\t\t//  console.log(games.length)\r\n\r\n\t\t\t\t\t\tfor(let j = games.length - 1; j >= 0; j--) {\r\n\t\t\t\t\t\t\t// validation\r\n\t\t\t\t\t\t\tif(gamenum > 100) {\tbreak;\t}\t// break if exceed limit. In future not hardcode\r\n\t\t\t\t\t\t\tif(games[j].rules !== \"chess\") { continue; } // check if rules are chess or variant\r\n\r\n\t\t\t\t\t\t\tconst id = IDfromURL(games[j].url);\r\n\t\t\t\t\t\t\tconst color = ColorfromGame(games[j], store.getState().UserName);\r\n\t\t\t\t\t\t\tconst result = ResultFromGame(games[j], color);\r\n\t\t\t\t\t\t\tconst tc = TimeControlFromGame(games[j]);\r\n\t\t\t\t\t\t\tconst tclass = TimeClassFromGame(games[j]);\r\n\t\t\t\t\t\t\tconst date = DateFromGame(games[j]);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (!store.getState().Games.includes(id)) { \t// could implement binarysearch in the future\r\n\t\t\t\t\t\t\t\tstore.getState().AddGame(id, color, result, tc, tclass, date);\r\n\t\t\t\t\t\t\t\tgamenum += 1;\r\n\t\t\t\t\t\t\t\tstore.getState().SetNeedAnalysis();\t// performance optim: only do once\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t// console.log(\"GN in loop: \", gamenum)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\ti--;\t\r\n\t\t\t}\r\n\t\t\t// console.log(\"gameids state: \", store.getState().Games)\r\n\r\n\t\t// Analyze();\r\n}","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\State\\store.js",[],"C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\urls.js",[],"C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\helpers.js",["69","70","71"],"import axios from \"axios\";\r\n\r\n/**\r\n * @param {string} url the incomplete url\r\n * @param {string | number} replacement the replacement to fill the url\r\n * @returns {string} the completed url\r\n */\r\nexport const CreateURL = (url, replacement) => {\r\n\treturn url.replace(\"{}\", replacement);\r\n}\r\n\r\n/**\r\n * \r\n * @param {string} url The URL to get a response from\r\n * @returns {promise} Promise with requested url\r\n */\r\nexport const GetURL = async (url) => {\r\n\treturn axios.get(url);\r\n}\r\n\r\n/**\r\n * \r\n * @param {string} url The URL with a Game ID in it \r\n * @returns {number} The game id\r\n * @throws Error if too many matches (!= 1)\r\n */\r\nexport const IDfromURL = (url) => {\r\n\tconst id = url.match(/\\d{1,13}/g)\r\n\r\n\tif(id.length !== 1) {\r\n\t\tthrow {\r\n\t\t\tmessage: \"IDfromURL to many matches\",\r\n\t\t\tobj: id\r\n\t\t} \r\n\t}\r\n\r\n\treturn Number(id[0])\r\n}\r\n\r\n/**\r\n * @param {string} username the players username\r\n * @param {object} gameObj The game object of a game\r\n */\r\nexport const ColorfromGame = (gameObj, uname) => {\r\n\tif(uname === gameObj.white.username) {\r\n\t\treturn \"white\";\r\n\t}\r\n\r\n\telse if(uname === gameObj.black.username) {\r\n\t\treturn \"black\";\r\n\t}\r\n\r\n\telse {\r\n\t\tthrow {\r\n\t\t\tmessage: \"Cannot find username in game. Perhaps this is the wrong game ID\",\r\n\t\t\tusername: uname,\r\n\t\t\twhite: gameObj.white.username,\r\n\t\t\tblack: gameObj.black.username\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport const TimeControlFromGame = (gameObj) => {\r\n\treturn gameObj.time_control;\r\n}\r\n\r\nexport const TimeClassFromGame = (gameObj) => {\r\n\treturn gameObj.time_class;\r\n}\r\n\r\nexport const DateFromGame = (gameObj) => {\r\n\treturn gameObj.end_time;\r\n}\r\n\r\n/**\r\n * \r\n * @param {object} gameObj the game object of a game\r\n * @param {string} color the player's color\r\n */\r\nexport const ResultFromGame = (gameObj, color) => {\r\n\t// console.log(color)\r\n\tif(color !== \"white\" && color !== \"black\") {\r\n\t\tthrow {\r\n\t\t\tmessage: \"Not a valid color\",\r\n\t\t\tcolor: color\r\n\t\t}\r\n\t}\r\n\r\n\treturn gameObj[color].result;\r\n}\r\n\r\n","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\components\\LoadForm.js",["72"],"import React, { useState } from 'react';\r\nimport { store } from '../State/store';\r\n\r\nconst LoadForm = () => {\r\n    const [uname, setUname] = useState(\"\");\r\n\r\n    <form>\r\n        <input \r\n            type=\"text\" \r\n            value={uname} \r\n            onChange ={(e) => setUname(e.targe.value)} \r\n            placeholder=\"Player Name\" \r\n            name=\"username\"></input>\r\n        <button>Submit</button>\r\n\t</form>\r\n}\r\n\r\nexport default LoadForm;\r\n","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\Analyze.js",["73","74","75","76","77","78","79","80","81"],"C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\AnalyzeHelpers.js",["82","83","84","85","86","87","88","89","90","91","92","93","94"],"import { CreateURL, GetURL } from './helpers';\r\nimport { CorsProxy, GetAnalysisURL, NewAnalysisURL } from './urls'\r\nimport { store } from '../State/store'\r\n\r\n/**\r\n * \r\n * @param {string|number} id The game id\r\n * @returns {promise} The game data\r\n * @todo Need better error handling\r\n */\r\nexport const getGameData = async (id, time = 1) => {\r\n    // function input validation\r\n    ValidGameID(id);\r\n    if(time <= 0 || time >= 5) {\r\n        throw {\r\n            message: \"Invoked getGameData too many times\",\r\n            the_id: id,\r\n            the_time: time\r\n        }\r\n    }\r\n\r\n    return getGameAnalysis(id)\r\n            .then((res) => {\r\n                // console.log(\"Game data: \", res.data)\r\n\r\n                if(!res.data.data) {\r\n                    if(time === 1) {\r\n                        console.log(id);\r\n                        newAnalysis(id);\r\n                        return new Promise((resolve) => {\r\n                            setTimeout(() => { return resolve(getGameData(id,time+1))}, 61000)\r\n                        })\r\n                    }\r\n                    else if (time <= 3) {\r\n                        console.warn(`Tried to retrieve game ${id} ${time} times`)\r\n                        // if(time === 3) { newAnalysis(id); /* try to restart again */ }\r\n                        newAnalysis(id);\r\n                        \r\n                        return new Promise((resolve) => {\r\n                            setTimeout(() => { return resolve(getGameData(id,time+1))}, 61000)\r\n                        })\r\n                    }\r\n                    if (time === 4) {\r\n                        throw {\r\n                            message: `Could not retrieve game data got ${id} after 3 attempts`,\r\n                            response: res.data\r\n                        }\r\n                    }\r\n                }\r\n                // got data values\r\n                else {\r\n                    console.log(`got data for: ${id}`)\r\n                    return res.data.data.analysis;\r\n                }\r\n\r\n            }).catch(err => {\r\n                console.warn(err.message)\r\n            });\r\n}\r\n\r\n/**\r\n * @description Opens window of the analysis report which should\r\n * start the analysis\r\n * @param {string|number} id The game id\r\n * @returns {void}\r\n */\r\nexport const newAnalysis = async ( id ) => {\r\n    ValidGameID(id);\r\n\r\n    return openWindow(CreateURL(NewAnalysisURL, id))\r\n}\r\n\r\n/**\r\n * @param {string} url opens window in new tab and closes tab after 5 seconds\r\n * @returns timer to close window\r\n * @todo add check if tab is null to handle the error\r\n */\r\nexport const openWindow = async ( url ) => {\r\n    if (typeof(url) !== \"string\") {\r\n        throw {\r\n            message: \"URL is not a valid string\",\r\n            type: typeof(url),\r\n            the_url: url\r\n        }\r\n    }\r\n\r\n    const tab = window.open(url, '_blank');\r\n    return setTimeout(() => tab.close(), 10000) // \r\n}\r\n\r\n/**\r\n * @param {number|string} id The id of the game\r\n * @returns {JSON} The json result of the request \r\n * @throws Error if id not a number\r\n */\r\nexport const getGameAnalysis = async ( id ) => {\r\n    // Check if input is valid\r\n    ValidGameID(id);\r\n\r\n    return GetURL(CreateURL(CorsProxy + GetAnalysisURL, id));\r\n}\r\n\r\n/**\r\n * \r\n * @param {number|string} id checks if the GameID is valid\r\n */\r\nexport const ValidGameID = (id) => {\r\n    if (Number(id) === NaN || Number(id) <= 1) {    // I believe 2 is the lowest game id\r\n        throw {\r\n            message: \"ID is not a valid number\",\r\n            type: typeof(id),\r\n            the_id: id\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * \r\n * @param {number} ply The ply to compare\r\n * @param {array} phaseArr The array of phases\r\n */\r\nexport const phase = (ply, phaseArr) => {\r\n    ply = Number(ply);\r\n    const numPhases = phaseArr.length;\r\n\r\n\r\n    if(ply === NaN || ply < 0) {\r\n        throw {\r\n            message: \"Invalid ply.\",\r\n            ply: ply\r\n        }\r\n    }\r\n\r\n\r\n    if(numPhases === 0 || ply < phaseArr[0]) {\r\n        return \"open\";\r\n    } else if(numPhases === 1 || ply < phaseArr[1]) {\r\n        return \"middle\";\r\n    } \r\n    \r\n    return \"end\";\r\n}\r\n\r\n/**\r\n * \r\n * @param {number} ply The ply to compare\r\n * @param {number} total The total number of ply\r\n */\r\nexport const plyPercent = (ply, total) => {\r\n    ply = Number(ply)\r\n    total = Number(total)\r\n\r\n    if(ply === NaN || total === NaN) {\r\n        throw {\r\n            message: \"Invalid ply or total ply\",\r\n            ply: ply,\r\n            total: total\r\n        }\r\n    } else if(ply < 0 || total < 0) {\r\n        throw {\r\n            message: \"Ply cannot be negative\",\r\n            ply: ply,\r\n            total: total\r\n        }\r\n    }\r\n\r\n    if(total - 1 !== 0) {\r\n        return (ply / (total - 1)) * 100 // total positions includes start so -1\r\n    } \r\n    \r\n    return (ply / total) * 100\r\n}\r\n\r\n\r\n/**\r\n * \r\n * @param {string} timecontrol The time control\r\n */\r\nexport const totalFromTC = (timecontrol) => {\r\n    return parseInt(timecontrol);\r\n}\r\n\r\n/**\r\n * \r\n * @param {string} timecontrol The time control\r\n */\r\nexport const incFromTC = (timecontrol) => {\r\n    let increment = parseInt(timecontrol.match(/\\+\\d*/g));\r\n        increment = (increment) ? increment : 0;\r\n\r\n    return increment;\r\n}\r\n/**\r\n * \r\n * @param {array} data array of the time for each move\r\n * @param {number} ply The current ply\r\n * @param {string} timecontrol The time control of the game\r\n * @todo check if ply is valid\r\n */\r\nexport const calculateClockTime = (times, ply, timecontrol) => {\r\n    const total = totalFromTC(timecontrol);\r\n    const increment = incFromTC(timecontrol);\r\n\r\n    if(total === NaN || total <= 0 || increment < 0) {\r\n        throw {\r\n            message: \"Invalid time control or increment\",\r\n            total: total,\r\n            increment: increment\r\n        }\r\n    }\r\n\r\n    // if(ply) \r\n\r\n\r\n    let final = total;\r\n    // console.log(final)\r\n    // gives time NOT including the time for ply\r\n    // i.e. calculates time on clock on start of ply\r\n    for(let i = ply % 2; i < ply; i += 2) { \r\n        final = final - times[i] / 10 + increment;\r\n        // console.log(final, times[i] / 10, increment)\r\n    }\r\n\r\n    return final;\r\n} \r\n\r\n\r\nexport const SameTacticType = (actual, user) => {\r\n    const regex = \"\\\\b\" + user + \"\\\\b\";\r\n    const index = actual.toLowerCase().search(new RegExp(regex))\r\n\r\n    // console.log(regex, actual, index)\r\n\r\n    if (index !== -1) {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n    // ele.type.toLowerCase().indexOf(new RegExp(\"\\b\" + name + \"\\b\",g)) !== -1\r\n}\r\n\r\n// in major need of a refactoring\r\nexport const UpdateTacticsState = (name, record) => {\r\n    name = name.toLowerCase();\r\n    // console.log(name)\r\n\r\n    if(SameTacticType(name, \"trapped piece\")) { \r\n        record.type.name = \"trapped\";\r\n        store.getState().addTactic(\"trapped\",record); return;\r\n    }\r\n\r\n    if(SameTacticType(name, \"skewer\")) { \r\n        record.type.name = \"skewer\";\r\n        store.getState().addTactic(\"skewer\",record); return;\r\n    }\r\n\r\n    if(SameTacticType(name,\"fork\")) {\r\n        // console.log(\"added fork\", record)\r\n        // console.log(record.type.type)\r\n        // console.log(re)\r\n        record.type.name = \"fork\"; \r\n        store.getState().addTactic(\"fork\", record); return; \r\n    }\r\n\r\n    if(SameTacticType(name,\"mate\") || SameTacticType(record.type.group, \"checkmate\")) { \r\n        record.type.name = \"mate\"; \r\n        store.getState().addTactic(\"mate\", record); return; \r\n    }\r\n    if(SameTacticType(name,\"material left undefended\") || SameTacticType(name, \"undefended material\")) { \r\n        // console.log(\"added hanging\", record)\r\n        record.type.name = \"hanging\";\r\n        store.getState().addTactic(\"hanging\", record); return; \r\n    }\r\n    \r\n\r\n    if(SameTacticType(name, \"under-defended material\")) {\r\n        record.type.name = \"underdefended\";\r\n        store.getState().addTactic(\"underdefended\", record); return;\r\n    }\r\n\r\n    if(SameTacticType(name, \"winning exchange\")) {\r\n        // console.log(\"adding winning exchange\")\r\n        record.type.name = \"winning exchange\";\r\n        store.getState().addTactic(\"winningExchange\", record); return;\r\n    }\r\n\r\n    if(name.includes(\"pin\")) { \r\n        if(record.type.group.includes(\"relative\") || record.type.type.includes(\"relative\")) {\r\n            record.type.name = \"relative pin\";\r\n            store.getState().addTactic(\"relativePin\", record); return; \r\n        }\r\n        record.type.name = \"absolute pin\";\r\n        store.getState().addTactic(\"absolutePin\", record); return; \r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @description Returns the opposite color of parameter\r\n * @param {string} color The initial color\r\n */\r\nexport const oppositeColor = (color) => {\r\n    // console.log(color.toLowerCase())\r\n    if(color.toLowerCase() !== \"white\" && color.toLowerCase() !== \"black\") {\r\n        console.warn({\r\n            message: \"Not a known color\",\r\n            color: color\r\n        })\r\n    }\r\n\r\n    return (color === \"white\") ? \"black\" : \"white\";\r\n}\r\n","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\AnalysisMetrics.js",["95","96","97"],"import { store } from '../State/store';\r\nimport { phase, plyPercent, calculateClockTime, totalFromTC, SameTacticType, UpdateTacticsState, oppositeColor } from './AnalyzeHelpers';\r\nimport { GetCurrentFen } from './fen';\r\nimport { CreateRecordProto, CreateTacticRecord } from './RecordPrototypes';\r\n\r\nexport const AddCaps = (data, gameObj) => {\r\n    const caps = data?.CAPS?.[gameObj.color]?.all;\r\n    if(caps === undefined) {\r\n        console.warn(`data.CAPS is undefined for ${gameObj.id} ${gameObj.color}`);\r\n        return;\r\n    }\r\n\r\n    store.getState().AddCAPStoGame(gameObj.id, caps)\r\n    console.log(store.getState().Games)\r\n}\r\n\r\n/**\r\n * \r\n * @param {object} data The returned data object\r\n * @param {object} gameObj The game object\r\n */\r\n\r\nexport const AnalyzeCastle = ( data, gameObj ) => {\r\n\r\n    const record = CreateRecordProto(data, gameObj);\r\n    let plyCastled = data?.castled[gameObj.color];\r\n\r\n    if(plyCastled === undefined || plyCastled === null || !(typeof(plyCastled) === \"number\")) {\r\n        console.warn({\r\n            message: \"Ply castled is undefined (data.castled[gameObj.color])\",\r\n            id: gameObj.id,\r\n            color: gameObj.color,\r\n            plyCastled: plyCastled\r\n        })\r\n        return;\r\n    }\r\n\r\n    if(plyCastled != -1) { // -1 means did not castle\r\n        plyCastled++;   // correct for TRUE ply (data starts @ 0 when should start at 1)\r\n\r\n        record.castled = true;\r\n        record.ply = plyCastled;\r\n        record.plyPercent = plyPercent(plyCastled, data.totalPositions)\r\n        record.phase = phase(plyCastled, data.gamePhases);\r\n        \r\n        record.fen = GetCurrentFen(data, record.ply, record.id)\r\n    } else {\r\n        record.castled = false;\r\n    }\r\n\r\n    store.getState().addCastled(record);\r\n    console.log(store.getState().castled);\r\n}\r\n\r\n\r\n/**\r\n * \r\n * @param {string} type \"inaccuracy, mistake, blunder\"\r\n * @param {object} data the analysis object\r\n * @param {object} gameObj the game object\r\n */\r\nexport const AnalyzeClassification = (type, data, gameObj) => {\r\n    // constants\r\n\tconst allowed = [\"blunder\", \"mistake\", \"inaccuracy\"];\r\n    const p = data?.positions;\r\n    const totalType = data?.tallies?.report?.[gameObj.color]?.[type];\r\n    \r\n    // input validation\r\n    if(!allowed.includes(type)) {\r\n        throw {\r\n            message: \"invalid move type\",\r\n            type: type\r\n        }\r\n    }\r\n\r\n    if(p === undefined || p === null || !p) {\r\n        console.warn({\r\n            message: \"positions is undefined\",\r\n            id: gameObj.id,\r\n            color: gameObj.color,\r\n            p: p\r\n        })\r\n        return;\r\n    }\r\n    if(totalType === undefined || totalType === null || !(typeof(totalType) === \"number\")) {\r\n        console.warn({\r\n            message: \"totalType is undefined\",\r\n            id: gameObj.id,\r\n            color: gameObj.color,\r\n            totalType: totalType\r\n        })\r\n        return;\r\n    }\r\n    \r\n\r\n    let count = 0;\r\n    let i = (p[0].color === gameObj.color) ? 0 : 1;\r\n    const recordProto = CreateRecordProto(data, gameObj);\r\n\r\n    if(totalType !== 0) {\r\n\r\n        while(count < totalType && i <= data.totalPositions - 2) {\r\n            if(p[i].classificationName === type) {\r\n                let record = {...recordProto};\r\n\r\n                // console.log(\"index: \", i, p[i], record)\r\n                record.score = p[i].playedMove.score;\r\n                record.difference = p[i].difference;\r\n                record.scenarios = p[i].scenarios;\r\n\r\n                record.ply = i + 1; // starts @ 0 so increment\r\n                record.plyPercent = plyPercent(record.ply, data.totalPositions)\r\n                record.phase = phase(record.ply, data.gamePhases);\r\n\r\n                record.fen = GetCurrentFen(data, record.ply, record.id)\r\n\r\n                if(data.time) {\r\n                    // console.log(\"id: \", gameObj.id, data)\r\n                    record.timeSpent = data.time.moves[i] / 10;\r\n                    record.timeToThink = calculateClockTime(data.time.moves, i, gameObj.timecontrol);\r\n                    record.timeToThinkPercent = record.timeToThink / totalFromTC(gameObj.timecontrol) * 100\r\n                }\r\n                // **************************** COME BACK AND CHECK THIS\r\n                // record.takeaway = {\r\n                //     type: data.TEP.takeaways[i]?.[0].type, // need to check\r\n                // }\r\n\r\n                // console.log(record);\r\n                store.getState().addMoveType(type, record);\r\n                count++;\r\n            }\r\n            i += 2;\r\n        }\r\n    }\r\n\r\n    console.log(store.getState()[type])\r\n}\r\n\r\n/**\r\n * \r\n * @param {object} data The returned data object\r\n * @param {object} gameObj The game object\r\n */\r\nexport const AnalyzeOpenings = (data, gameObj) => {\r\n    if(data?.book === undefined) {\r\n        console.warn(`data.book undefined for ${gameObj.id} ${gameObj.color}`)\r\n    }\r\n    if(data?.bookPly === undefined) {\r\n        console.warn(`data.book undefined for ${gameObj.id} ${gameObj.color}`)\r\n    }\r\n\r\n    if(data?.CAPS?.[gameObj.color]?.all === undefined) {\r\n        console.warn(`data.CAPS is undefined for ${gameObj.id} ${gameObj.color}`)\r\n    }\r\n\r\n    const record = CreateRecordProto(data, gameObj);\r\n          record.caps = data?.CAPS?.[gameObj.color]?.all;\r\n          record.name = data?.book?.name;\r\n          record.bookPly = data?.bookPly;\r\n          record.lastBookFEN = GetCurrentFen(data, record.bookPly + 1, gameObj.id)\r\n\r\n    store.getState().addOpening(record);\r\n    // console.log(store.getState().opening);\r\n}\r\n\r\n\r\n/**\r\n * \r\n * @param {object} data The analysis data\r\n * @param {object} gameObj the game object\r\n */\r\nexport const AnalyzeGamePatterns = (data, gameObj) => {\r\n\r\n    const record = CreateRecordProto(data, gameObj);\r\n    const d = data?.TEP?.moves?.[gameObj.color] // rename to make easier to work with\r\n\r\n    if(d === undefined || d === null || !d) {\r\n        console.warn({\r\n            message: \"data.TEP.moves[gameObj.color] is undefined\",\r\n            id: gameObj.id,\r\n            color: gameObj.color\r\n        })\r\n        return;\r\n    }\r\n\r\n    for(const i in d) {\r\n\r\n        let p = new Array();\r\n        for(const j of d[i]) {\r\n            let phs = phase(j, data.gamePhases);\r\n\r\n            if(!p.includes(phs)) { p.push(phs); }\r\n            if(p.length === 3) break;   // shortcircuit if already complete\r\n        }\r\n\r\n        record[i] = {\r\n            plyPresent: i.length,\r\n            PercentPresent: plyPercent(i.length, data.totalPositions),\r\n            phase: p\r\n        }\r\n    }\r\n\r\n    store.getState().addGamePattern(record)\r\n    // console.log(store.getState().gamePatterns)\r\n}\r\n\r\n/**\r\n * \r\n * @param {object} data The data analysis object\r\n * @param {object} gameObj The game object\r\n */\r\nexport const AnalyzeAllTactics = (data, gameObj) => {\r\n    const KnownTacticsTypes = [\r\n        \"fork\", \"mate\",\"material left undefended\",\r\n        \"undefended material\",\"pin\",\"trapped piece\",\r\n        \"under-defended material\", \"winning exchange\",\r\n        \"skewer\"\r\n    ];\r\n\r\n    const p = data?.positions;\r\n    const t = data?.TEP?.takeaways;\r\n\r\n    if(p === undefined || p === null || !p) {\r\n        console.warn({\r\n            message: \"positions is undefined\",\r\n            id: gameObj.id,\r\n            color: gameObj.color,\r\n            p: p\r\n        })\r\n        return;\r\n    }\r\n\r\n    if(t === undefined || t === null || !t) {\r\n        console.warn({\r\n            message: \"takeaways is undefined\",\r\n            id: gameObj.id,\r\n            color: gameObj.color,\r\n            t: t\r\n        })\r\n        return;\r\n    }\r\n\r\n    for(let i in t) {\r\n        i = Number(i)\r\n\r\n        for(let j = 0; j < t[i].length; j++) {\r\n            const ele = t[i]?.[j]\r\n\r\n            // console.log(t, t.i, i, typeof(i), ele, ele?.color)\r\n            if (ele?.color === gameObj.color) {\r\n                // console.log(ele.type)\r\n\r\n                // warn if type is not in the known array\r\n                if(!KnownTacticsTypes.some((e) => SameTacticType(ele.type, e))) {\r\n                    console.warn(\"Not included\", ele.type, gameObj.id) // if gets here then it is a new type of tactic\r\n                }\r\n\r\n                else {\r\n                    console.warn(ele.type)\r\n\r\n                    const record = CreateTacticRecord(i-1,ele,p,data,gameObj)\r\n                    // console.log(record);\r\n                    \r\n                    UpdateTacticsState(ele.type, record);\r\n                }\r\n            } \r\n            // NEEDS a BUNCH of refactoring, but at least it works\r\n            else if(oppositeColor(ele?.color) === gameObj.color && ele.class === \"blunders\") {\r\n                console.log(\"first\")\r\n                if(!t[i + 1] || t[i + 1].length === 0) {\r\n                    console.log(\"second\")\r\n\r\n                    if(p[i].playedMove.moveLan !== ele.eval.pv[0]) {\r\n                        console.log(\"third\")\r\n                        if(p[i].classificationName === \"blunder\" || p[i].classificationName === \"mistake\") {\r\n                            \r\n                                console.log(\"final\")\r\n\r\n                                // passed all the checks so now add this \r\n                                // warn if type is not in the known array\r\n                                if(!KnownTacticsTypes.some((e) => SameTacticType(ele.type, e))) {\r\n                                    console.warn(\"Opp: Not included\", ele.type, gameObj.id) // if gets here then it is a new type of tactic\r\n                                }\r\n\r\n                                else {\r\n                                    console.log(\"fourth\")\r\n                                    console.warn(\"opp: \", ele.type)\r\n                    \r\n                                    const record = CreateTacticRecord(i,ele,p,data,gameObj,\"missed\")\r\n                                    console.log(record)\r\n\r\n                                    UpdateTacticsState(ele.type, record);\r\n                                } \r\n                        }\r\n        \r\n                    } else { // they are equal so you got the tactic\r\n                        console.log(\"final\")\r\n\r\n                        // passed all the checks so now add this \r\n                        // warn if type is not in the known array\r\n                        if(!KnownTacticsTypes.some((e) => SameTacticType(ele.type, e))) {\r\n                            console.warn(\"Opp: Not included\", ele.type, gameObj.id) // if gets here then it is a new type of tactic\r\n                        }\r\n\r\n                        else {\r\n                            console.log(\"fourth\")\r\n                            console.warn(\"opp: \", ele.type)\r\n            \r\n                            const record = CreateTacticRecord(i,ele,p,data,gameObj,\"got\")\r\n                            console.log(record)\r\n\r\n                            UpdateTacticsState(ele.type, record);\r\n                        } \r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport const AnalyzeEndgames = (data, gameObj) => {\r\n    // const record = CreateRecordProto(data, gameObj);\r\n    const d = data?.TEP?.endgames; // rename to make easier to work with\r\n\r\n    if(d.length > 0) {\r\n        console.warn(d)\r\n    }\r\n}","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\RecordPrototypes.js",[],"C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\fen.js",[],"C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\Charts\\CAPS.js",[],{"ruleId":"98","severity":1,"message":"99","line":4,"column":10,"nodeType":"100","messageId":"101","endLine":4,"endColumn":18},{"ruleId":"102","replacedBy":"103"},{"ruleId":"104","replacedBy":"105"},{"ruleId":"98","severity":1,"message":"106","line":3,"column":8,"nodeType":"100","messageId":"101","endLine":3,"endColumn":16},{"ruleId":"98","severity":1,"message":"107","line":13,"column":22,"nodeType":"100","messageId":"101","endLine":13,"endColumn":36},{"ruleId":"98","severity":1,"message":"108","line":12,"column":10,"nodeType":"100","messageId":"101","endLine":12,"endColumn":17},{"ruleId":"109","severity":1,"message":"110","line":81,"column":12,"nodeType":"111","messageId":"112","endLine":106,"endColumn":7},{"ruleId":"113","severity":1,"message":"114","line":31,"column":3,"nodeType":"115","messageId":"116","endLine":34,"endColumn":4},{"ruleId":"113","severity":1,"message":"114","line":54,"column":3,"nodeType":"115","messageId":"116","endLine":59,"endColumn":4},{"ruleId":"113","severity":1,"message":"114","line":83,"column":3,"nodeType":"115","messageId":"116","endLine":86,"endColumn":4},{"ruleId":"98","severity":1,"message":"117","line":2,"column":10,"nodeType":"100","messageId":"101","endLine":2,"endColumn":15},{"ruleId":"98","severity":1,"message":"118","line":1,"column":23,"nodeType":"100","messageId":"101","endLine":1,"endColumn":28},{"ruleId":"98","severity":1,"message":"119","line":1,"column":30,"nodeType":"100","messageId":"101","endLine":1,"endColumn":40},{"ruleId":"98","severity":1,"message":"120","line":4,"column":5,"nodeType":"100","messageId":"101","endLine":4,"endColumn":18},{"ruleId":"98","severity":1,"message":"121","line":5,"column":5,"nodeType":"100","messageId":"101","endLine":5,"endColumn":26},{"ruleId":"98","severity":1,"message":"122","line":6,"column":5,"nodeType":"100","messageId":"101","endLine":6,"endColumn":20},{"ruleId":"98","severity":1,"message":"123","line":7,"column":5,"nodeType":"100","messageId":"101","endLine":7,"endColumn":24},{"ruleId":"98","severity":1,"message":"124","line":8,"column":5,"nodeType":"100","messageId":"101","endLine":8,"endColumn":22},{"ruleId":"98","severity":1,"message":"125","line":9,"column":5,"nodeType":"100","messageId":"101","endLine":9,"endColumn":20},{"ruleId":"113","severity":1,"message":"114","line":25,"column":9,"nodeType":"115","messageId":"116","endLine":29,"endColumn":10},{"ruleId":"113","severity":1,"message":"114","line":15,"column":9,"nodeType":"115","messageId":"116","endLine":19,"endColumn":10},{"ruleId":"113","severity":1,"message":"114","line":44,"column":25,"nodeType":"115","messageId":"116","endLine":47,"endColumn":26},{"ruleId":"113","severity":1,"message":"114","line":80,"column":9,"nodeType":"115","messageId":"116","endLine":84,"endColumn":10},{"ruleId":"126","severity":1,"message":"127","line":108,"column":9,"nodeType":"128","messageId":"129","endLine":108,"endColumn":27},{"ruleId":"113","severity":1,"message":"114","line":109,"column":9,"nodeType":"115","messageId":"116","endLine":113,"endColumn":10},{"ruleId":"126","severity":1,"message":"127","line":127,"column":8,"nodeType":"128","messageId":"129","endLine":127,"endColumn":19},{"ruleId":"113","severity":1,"message":"114","line":128,"column":9,"nodeType":"115","messageId":"116","endLine":131,"endColumn":10},{"ruleId":"126","severity":1,"message":"127","line":153,"column":8,"nodeType":"128","messageId":"129","endLine":153,"endColumn":19},{"ruleId":"126","severity":1,"message":"127","line":153,"column":23,"nodeType":"128","messageId":"129","endLine":153,"endColumn":36},{"ruleId":"113","severity":1,"message":"114","line":154,"column":9,"nodeType":"115","messageId":"116","endLine":158,"endColumn":10},{"ruleId":"113","severity":1,"message":"114","line":160,"column":9,"nodeType":"115","messageId":"116","endLine":164,"endColumn":10},{"ruleId":"126","severity":1,"message":"127","line":204,"column":8,"nodeType":"128","messageId":"129","endLine":204,"endColumn":21},{"ruleId":"113","severity":1,"message":"114","line":205,"column":9,"nodeType":"115","messageId":"116","endLine":209,"endColumn":10},{"ruleId":"130","severity":1,"message":"131","line":38,"column":19,"nodeType":"128","messageId":"132","endLine":38,"endColumn":21},{"ruleId":"113","severity":1,"message":"114","line":70,"column":9,"nodeType":"115","messageId":"116","endLine":73,"endColumn":10},{"ruleId":"133","severity":1,"message":"134","line":188,"column":17,"nodeType":"135","messageId":"136","endLine":188,"endColumn":28},"no-unused-vars","'Provider' is defined but never used.","Identifier","unusedVar","no-native-reassign",["137"],"no-negated-in-lhs",["138"],"'LoadForm' is defined but never used.","'setInitialized' is assigned a value but never used.","'Analyze' is defined but never used.","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'games', 'games', 'gamenum', 'games', 'games', 'games', 'games', 'games', 'games', 'games', 'gamenum'.","ArrowFunctionExpression","unsafeRefs","no-throw-literal","Expected an error object to be thrown.","ThrowStatement","object","'store' is defined but never used.","'phase' is defined but never used.","'plyPercent' is defined but never used.","'AnalyzeCastle' is defined but never used.","'AnalyzeClassification' is defined but never used.","'AnalyzeOpenings' is defined but never used.","'AnalyzeGamePatterns' is defined but never used.","'AnalyzeAllTactics' is defined but never used.","'AnalyzeEndgames' is defined but never used.","use-isnan","Use the isNaN function to compare with NaN.","BinaryExpression","comparisonWithNaN","eqeqeq","Expected '!==' and instead saw '!='.","unexpected","no-array-constructor","The array literal notation [] is preferable.","NewExpression","preferLiteral","no-global-assign","no-unsafe-negation"]