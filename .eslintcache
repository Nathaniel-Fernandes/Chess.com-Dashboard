[{"C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\index.js":"1","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\App.js":"2","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\Initialize.js":"3","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\State\\store.js":"4","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\urls.js":"5","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\helpers.js":"6","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\components\\LoadForm.js":"7","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\Analyze.js":"8","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\AnalyzeHelpers.js":"9","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\AnalysisMetrics.js":"10"},{"size":235,"mtime":1607466474208,"results":"11","hashOfConfig":"12"},{"size":1272,"mtime":1607748047057,"results":"13","hashOfConfig":"12"},{"size":3672,"mtime":1607798113806,"results":"14","hashOfConfig":"12"},{"size":2713,"mtime":1607798756295,"results":"15","hashOfConfig":"12"},{"size":579,"mtime":1607554564394,"results":"16","hashOfConfig":"12"},{"size":1935,"mtime":1607664211548,"results":"17","hashOfConfig":"12"},{"size":450,"mtime":1607486841061,"results":"18","hashOfConfig":"12"},{"size":1129,"mtime":1607797202260,"results":"19","hashOfConfig":"12"},{"size":6152,"mtime":1607744713248,"results":"20","hashOfConfig":"12"},{"size":16744,"mtime":1607796178374,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"24","usedDeprecatedRules":"25"},"gju65z",{"filePath":"26","messages":"27","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"28","usedDeprecatedRules":"25"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31","usedDeprecatedRules":"25"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"25"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"38","usedDeprecatedRules":"25"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41","usedDeprecatedRules":"25"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"44","usedDeprecatedRules":"25"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"48"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"51","usedDeprecatedRules":"25"},"C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\index.js",["52"],"import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport { Provider } from 'jotai'\n\n\nReactDOM.render(\n  <React.StrictMode>\n      <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n\n",["53","54"],"C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\App.js",["55","56"],"import React, { useEffect, useState } from 'react';\nimport { initializeState } from \"./BusinessLogic/Initialize\";\nimport LoadForm from './components/LoadForm';\nimport { store } from './State/store';\n\nfunction App() {\n\t// useEffect(() => {\n\t// \t// load initial state\n\t// \tinitializeState();\n\n\t// }, [])\n\tconst [initialized, setInitialized] = useState(false)\n\tconst [popupBlocker, setPopupBlocker] = useState(false);\n\t\n\tconst archive = store(state => state.GameArchive);\n\tconst gameID_arr = store(state => state.Games);\n\n\tuseEffect(() => {\n\t\tconst t = window.open('','_blank');\n\t\tif(t === null || t === undefined || !t) {\n\t\t\tsetPopupBlocker(true);\n\t\t\treturn;\n\t\t}\n\t\tt.close();\n\t\t// setTimeout()\n\t},[])\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        \n      </header>\n\t  {/* initializeState */}\n\t\t{/* <LoadForm /> */}\n\t\t{\n\t\t\t(popupBlocker) ? \"Please disable your popup blocker\" : ''\n\t\t}\n\t\t{\n\t\t\t(!initialized) ? <button onClick={() => {\n\t\t\t\tinitializeState()\n\t\t\t}}>Click to Start</button> : ''\n\t\t}\n\t\t\n\n\t\t<p>{(store.getState().loading) ? \"Loading\" : \"View\"}</p>\n\t\t<ol>\n\t\t\t{archive.map(\n\t\t\t\t(e) => <li>{e}</li>\n\t\t\t)}\n\t\t</ol>\n\t\t<br />\n\t\t<ol>\n\t\t\t{gameID_arr.map(\n\t\t\t\t(e) => <li>{e.id}</li>\n\t\t\t)}\n\t\t</ol>\n\n\n    </div>\n  );\n}\n\nexport default App;\n","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\Initialize.js",["57","58"],"import { store } from '../State/store';\r\nimport { ArchiveURL } from './urls';\r\nimport { \r\n\tColorfromGame, \r\n\tCreateURL, \r\n\tGetURL, \r\n\tIDfromURL, \r\n\tResultFromGame, \r\n\tTimeControlFromGame, \r\n\tTimeClassFromGame,\r\n\tDateFromGame } from './helpers';\r\nimport { Analyze, AnalyzeGame } from '../BusinessLogic/Analyze';\r\n\r\nexport const timeout = (ms = 5000) => { \r\n\treturn new Promise((resolve) => setTimeout(resolve, ms));\r\n}\r\n\r\nexport const initializeState = () => {\r\n\t// check if less then 100 games\r\n\tif (store.getState().Games.length < 100) {\r\n\r\n        GetURL(CreateURL(ArchiveURL, store.getState().UserName))\r\n\t\t\t.then((res, err) => {\r\n\t\t\t\t\t// primitive error handling\r\n\t\t\t\t\tif(err) { console.warn(err); return; }\r\n\t\t\t\t\telse if(res.data.status === 404) return;\r\n\r\n\t\t\t\t\tstore.getState().setGameArchives(res.data.archives)\t\t// think a synchronous call to update Archives\r\n\t\t\t\t\t// console.log(store.getState().GameArchive)\t\t\t\t// prints out updated state\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn GameIDfromArchive();\r\n\t\t\t})\r\n\t\t\t.then(async (res) => {\r\n\t\t\t\t// for(let i = 0; i < 10; i++) {\r\n\t\t\t\t\t// AnalyzeGame(store.getState().Games[1]);\r\n\t\t\t\t\t// AnalyzeGame(store.getState().Games[2]);\r\n\t\t\t\t\t// AnalyzeGame(store.getState().Games[76]);\r\n\t\t\t\t// }\r\n\t\t\t\tfor(let i = 0; i < 5; i++) {\r\n\t\t\t\t\tAnalyzeGame(store.getState().Games[i]);\r\n\t\t\t\t\tawait timeout(1000);\r\n\t\t\t\t}\r\n\t\t\t}).then(() => {\r\n\t\t\t\tconst tacticsObj = {\r\n\t\t\t\t\tfork: store.getState().fork,\r\n\t\t\t\t\tmate: store.getState().mate,\r\n\t\t\t\t\thanging: store.getState().hanging,\r\n\t\t\t\t\trelativePin: store.getState().relativePin,\r\n\t\t\t\t\tabsolutePin: store.getState().absolutePin,\r\n\t\t\t\t\ttrapped: store.getState().trapped,\r\n\t\t\t\t\tunderdefended: store.getState().underdefended,\r\n\t\t\t\t\twinningExchange: store.getState().winningExchange,\r\n\t\t\t\t\tskewer: store.getState().skewer,\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconsole.log(JSON.stringify(tacticsObj, null, '  '))\r\n\t\t\t})\r\n\t}\r\n}\r\n\r\n/**\r\n * @description Adds the GameIDs to GameID array from the archive\r\n * @returns {void} A promise  \r\n * @todo don't hardcode # of games\r\n */\r\nconst GameIDfromArchive = async () => {\r\n\t\t// console.log(\"Current Store: \", store.getState())\r\n\t\tlet archives = store.getState().GameArchive;\r\n\t\tlet i = archives.length - 1;\r\n\t\tlet gamenum = store.getState().Games.length;\r\n\t\tlet games;\r\n\r\n\t\t// TESTS\r\n\t\t// 1. <100 games\r\n\t\t// 2. >100 games\r\n\t\t// 3. multiple archives\r\n\t\t// (async _ => {\r\n\t\t\twhile(archives[i] && i >= 0 && gamenum <= 100) { \r\n\t\t\t\t// console.log(\"GM top loop: \", gamenum)\t\r\n\t\t\t\t\r\n\t\t\t\t// console.log(archives[i])\r\n\r\n\t\t\t\tawait GetURL(archives[i])\r\n\t\t\t\t\t.then(res => {\r\n\t\t\t\t\t\t//  console.log(res.data)\r\n\t\t\t\t\t\tgames = res.data.games\r\n\r\n\t\t\t\t\t\t//  console.log(games.length)\r\n\r\n\t\t\t\t\t\tfor(let j = 0; j < games.length; j++) {\r\n\t\t\t\t\t\t\t// validation\r\n\t\t\t\t\t\t\tif(gamenum > 100) {\tbreak;\t}\t// break if exceed limit. In future not hardcode\r\n\t\t\t\t\t\t\tif(games[j].rules !== \"chess\") { continue; } // check if rules are chess or variant\r\n\r\n\t\t\t\t\t\t\tconst id = IDfromURL(games[j].url);\r\n\t\t\t\t\t\t\tconst color = ColorfromGame(games[j], store.getState().UserName);\r\n\t\t\t\t\t\t\tconst result = ResultFromGame(games[j], color);\r\n\t\t\t\t\t\t\tconst tc = TimeControlFromGame(games[j]);\r\n\t\t\t\t\t\t\tconst tclass = TimeClassFromGame(games[j]);\r\n\t\t\t\t\t\t\tconst date = DateFromGame(games[j]);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (!store.getState().Games.includes(id)) { \t// could implement binarysearch in the future\r\n\t\t\t\t\t\t\t\tstore.getState().AddGame(id, color, result, tc, tclass, date);\r\n\t\t\t\t\t\t\t\tgamenum += 1;\r\n\t\t\t\t\t\t\t\tstore.getState().SetNeedAnalysis();\t// performance optim: only do once\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t// console.log(\"GN in loop: \", gamenum)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\ti--;\t\r\n\t\t\t}\r\n\t\t\t// console.log(\"gameids state: \", store.getState().Games)\r\n\r\n\t\t// Analyze();\r\n}","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\State\\store.js",[],"C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\urls.js",[],"C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\helpers.js",["59","60","61"],"import axios from \"axios\";\r\n\r\n/**\r\n * @param {string} url the incomplete url\r\n * @param {string | number} replacement the replacement to fill the url\r\n * @returns {string} the completed url\r\n */\r\nexport const CreateURL = (url, replacement) => {\r\n\treturn url.replace(\"{}\", replacement);\r\n}\r\n\r\n/**\r\n * \r\n * @param {string} url The URL to get a response from\r\n * @returns {promise} Promise with requested url\r\n */\r\nexport const GetURL = async (url) => {\r\n\treturn axios.get(url);\r\n}\r\n\r\n/**\r\n * \r\n * @param {string} url The URL with a Game ID in it \r\n * @returns {number} The game id\r\n * @throws Error if too many matches (!= 1)\r\n */\r\nexport const IDfromURL = (url) => {\r\n\tconst id = url.match(/\\d{1,13}/g)\r\n\r\n\tif(id.length !== 1) {\r\n\t\tthrow {\r\n\t\t\tmessage: \"IDfromURL to many matches\",\r\n\t\t\tobj: id\r\n\t\t} \r\n\t}\r\n\r\n\treturn Number(id[0])\r\n}\r\n\r\n/**\r\n * @param {string} username the players username\r\n * @param {object} gameObj The game object of a game\r\n */\r\nexport const ColorfromGame = (gameObj, uname) => {\r\n\tif(uname === gameObj.white.username) {\r\n\t\treturn \"white\";\r\n\t}\r\n\r\n\telse if(uname === gameObj.black.username) {\r\n\t\treturn \"black\";\r\n\t}\r\n\r\n\telse {\r\n\t\tthrow {\r\n\t\t\tmessage: \"Cannot find username in game. Perhaps this is the wrong game ID\",\r\n\t\t\tusername: uname,\r\n\t\t\twhite: gameObj.white.username,\r\n\t\t\tblack: gameObj.black.username\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport const TimeControlFromGame = (gameObj) => {\r\n\treturn gameObj.time_control;\r\n}\r\n\r\nexport const TimeClassFromGame = (gameObj) => {\r\n\treturn gameObj.time_class;\r\n}\r\n\r\nexport const DateFromGame = (gameObj) => {\r\n\treturn gameObj.end_time;\r\n}\r\n\r\n/**\r\n * \r\n * @param {object} gameObj the game object of a game\r\n * @param {string} color the player's color\r\n */\r\nexport const ResultFromGame = (gameObj, color) => {\r\n\t// console.log(color)\r\n\tif(color !== \"white\" && color !== \"black\") {\r\n\t\tthrow {\r\n\t\t\tmessage: \"Not a valid color\",\r\n\t\t\tcolor: color\r\n\t\t}\r\n\t}\r\n\r\n\treturn gameObj[color].result;\r\n}\r\n\r\n","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\components\\LoadForm.js",["62"],"import React, { useState } from 'react';\r\nimport { store } from '../State/store';\r\n\r\nconst LoadForm = () => {\r\n    const [uname, setUname] = useState(\"\");\r\n\r\n    <form>\r\n        <input \r\n            type=\"text\" \r\n            value={uname} \r\n            onChange ={(e) => setUname(e.targe.value)} \r\n            placeholder=\"Player Name\" \r\n            name=\"username\"></input>\r\n        <button>Submit</button>\r\n\t</form>\r\n}\r\n\r\nexport default LoadForm;\r\n","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\Analyze.js",["63","64","65","66"],"import { getGameData, phase, plyPercent, ValidGameID } from './AnalyzeHelpers';\r\nimport { store } from '../State/store';\r\nimport { \r\n    AnalyzeCastle, \r\n    AnalyzeClassification, \r\n    AnalyzeOpenings,\r\n    AnalyzeGamePatterns,\r\n    // AnalyzeAllTactics,\r\n    AnalyzeAllTactics2\r\n} from './AnalysisMetrics';\r\n\r\n/**\r\n * @description Analyzes the games\r\n * @param {string|number} id The id of the game to analyze\r\n */\r\nexport const AnalyzeGame = async (game) => {  \r\n    // function input validation\r\n    ValidGameID(game.id);\r\n\r\n    const data = await getGameData(game.id);\r\n    // console.log(\"game: \", game)\r\n\r\n    if(!data) {\r\n        throw {\r\n            message: `Data is undefined for ${game.id}`,\r\n            data: data,\r\n            game: game\r\n        }\r\n        // just get this to request another game\r\n    }\r\n\r\n    AnalyzeCastle(data, game);\r\n    AnalyzeOpenings(data, game);\r\n    AnalyzeClassification(\"blunder\", data,game);\r\n    AnalyzeClassification(\"mistake\", data,game);\r\n    AnalyzeClassification(\"inaccuracy\", data,game);\r\n    AnalyzeGamePatterns(data,game);\r\n    AnalyzeAllTactics2(data, game);\r\n    \r\n}\r\n\r\n","C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\AnalyzeHelpers.js",["67","68","69","70","71","72","73","74","75","76","77","78","79"],"import { CreateURL, GetURL } from './helpers';\r\nimport { CorsProxy, GetAnalysisURL, NewAnalysisURL } from './urls'\r\n\r\n/**\r\n * \r\n * @param {string|number} id The game id\r\n * @returns {promise} The game data\r\n * @todo Need better error handling\r\n */\r\nexport const getGameData = async (id, time = 1) => {\r\n    // function input validation\r\n    ValidGameID(id);\r\n    if(time <= 0 || time >= 5) {\r\n        throw {\r\n            message: \"Invoked getGameData too many times\",\r\n            the_id: id,\r\n            the_time: time\r\n        }\r\n    }\r\n\r\n    return getGameAnalysis(id)\r\n            .then((res) => {\r\n                // console.log(\"Game data: \", res.data)\r\n\r\n                if(!res.data.data) {\r\n                    if(time === 1) {\r\n                        console.log(id);\r\n                        newAnalysis(id);\r\n                        return new Promise((resolve) => {\r\n                            setTimeout(() => { return resolve(getGameData(id,time+1))}, 61000)\r\n                        })\r\n                    }\r\n                    else if (time <= 3) {\r\n                        console.warn(`Tried to retrieve game ${id} ${time} times`)\r\n                        // if(time === 3) { newAnalysis(id); /* try to restart again */ }\r\n                        newAnalysis(id);\r\n                        \r\n                        return new Promise((resolve) => {\r\n                            setTimeout(() => { return resolve(getGameData(id,time+1))}, 61000)\r\n                        })\r\n                    }\r\n                    if (time === 4) {\r\n                        throw {\r\n                            message: `Could not retrieve game data got ${id} after 3 attempts`,\r\n                            response: res.data\r\n                        }\r\n                    }\r\n                }\r\n                // got data values\r\n                else {\r\n                    console.log(`got data for: ${id}`)\r\n                    return res.data.data.analysis;\r\n                }\r\n\r\n            }).catch(err => {\r\n                console.warn(err.message)\r\n            });\r\n}\r\n\r\n/**\r\n * @description Opens window of the analysis report which should\r\n * start the analysis\r\n * @param {string|number} id The game id\r\n * @returns {void}\r\n */\r\nexport const newAnalysis = async ( id ) => {\r\n    ValidGameID(id);\r\n\r\n    return openWindow(CreateURL(NewAnalysisURL, id))\r\n}\r\n\r\n/**\r\n * @param {string} url opens window in new tab and closes tab after 5 seconds\r\n * @returns timer to close window\r\n * @todo add check if tab is null to handle the error\r\n */\r\nexport const openWindow = async ( url ) => {\r\n    if (typeof(url) !== \"string\") {\r\n        throw {\r\n            message: \"URL is not a valid string\",\r\n            type: typeof(url),\r\n            the_url: url\r\n        }\r\n    }\r\n\r\n    const tab = window.open(url, '_blank');\r\n    return setTimeout(() => tab.close(), 10000) // \r\n}\r\n\r\n/**\r\n * @param {number|string} id The id of the game\r\n * @returns {JSON} The json result of the request \r\n * @throws Error if id not a number\r\n */\r\nexport const getGameAnalysis = async ( id ) => {\r\n    // Check if input is valid\r\n    ValidGameID(id);\r\n\r\n    return GetURL(CreateURL(CorsProxy + GetAnalysisURL, id));\r\n}\r\n\r\n/**\r\n * \r\n * @param {number|string} id checks if the GameID is valid\r\n */\r\nexport const ValidGameID = (id) => {\r\n    if (Number(id) === NaN || Number(id) <= 1) {    // I believe 2 is the lowest game id\r\n        throw {\r\n            message: \"ID is not a valid number\",\r\n            type: typeof(id),\r\n            the_id: id\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * \r\n * @param {number} ply The ply to compare\r\n * @param {array} phaseArr The array of phases\r\n */\r\nexport const phase = (ply, phaseArr) => {\r\n    ply = Number(ply);\r\n    const numPhases = phaseArr.length;\r\n\r\n\r\n    if(ply === NaN || ply < 0) {\r\n        throw {\r\n            message: \"Invalid ply.\",\r\n            ply: ply\r\n        }\r\n    }\r\n\r\n\r\n    if(numPhases === 0 || ply < phaseArr[0]) {\r\n        return \"open\";\r\n    } else if(numPhases === 1 || ply < phaseArr[1]) {\r\n        return \"middle\";\r\n    } \r\n    \r\n    return \"end\";\r\n}\r\n\r\n/**\r\n * \r\n * @param {number} ply The ply to compare\r\n * @param {number} total The total number of ply\r\n */\r\nexport const plyPercent = (ply, total) => {\r\n    ply = Number(ply)\r\n    total = Number(total)\r\n\r\n    if(ply === NaN || total === NaN) {\r\n        throw {\r\n            message: \"Invalid ply or total ply\",\r\n            ply: ply,\r\n            total: total\r\n        }\r\n    } else if(ply < 0 || total < 0) {\r\n        throw {\r\n            message: \"Ply cannot be negative\",\r\n            ply: ply,\r\n            total: total\r\n        }\r\n    }\r\n\r\n    if(total - 1 !== 0) {\r\n        return (ply / (total - 1)) * 100 // total positions includes start so -1\r\n    } \r\n    \r\n    return (ply / total) * 100\r\n}\r\n\r\n\r\n/**\r\n * \r\n * @param {string} timecontrol The time control\r\n */\r\nexport const totalFromTC = (timecontrol) => {\r\n    return parseInt(timecontrol);\r\n}\r\n\r\n/**\r\n * \r\n * @param {string} timecontrol The time control\r\n */\r\nexport const incFromTC = (timecontrol) => {\r\n    let increment = parseInt(timecontrol.match(/\\+\\d*/g));\r\n        increment = (increment) ? increment : 0;\r\n\r\n    return increment;\r\n}\r\n/**\r\n * \r\n * @param {array} data array of the time for each move\r\n * @param {number} ply The current ply\r\n * @param {string} timecontrol The time control of the game\r\n * @todo check if ply is valid\r\n */\r\nexport const calculateClockTime = (times, ply, timecontrol) => {\r\n    const total = totalFromTC(timecontrol);\r\n    const increment = incFromTC(timecontrol);\r\n\r\n    if(total === NaN || total <= 0 || increment < 0) {\r\n        throw {\r\n            message: \"Invalid time control or increment\",\r\n            total: total,\r\n            increment: increment\r\n        }\r\n    }\r\n\r\n    // if(ply) \r\n\r\n\r\n    let final = total;\r\n    // console.log(final)\r\n    // gives time NOT including the time for ply\r\n    // i.e. calculates time on clock on start of ply\r\n    for(let i = ply % 2; i < ply; i += 2) { \r\n        final = final - times[i] / 10 + increment;\r\n        // console.log(final, times[i] / 10, increment)\r\n    }\r\n\r\n    return final;\r\n} \r\n\r\n",["80","81"],"C:\\Users\\Merlin\\Documents\\Coding\\ChessIntellect\\chess-dashboard\\src\\BusinessLogic\\AnalysisMetrics.js",["82","83","84"],"import { store } from '../State/store';\r\nimport { phase, plyPercent, calculateClockTime, totalFromTC } from './AnalyzeHelpers';\r\n\r\n/**\r\n* castled {\r\n        id: gameid\r\n        color\r\n        castled: true/false,\r\n        phase: open/middle/end\r\n        ply:\r\n        ply_percent:\r\n        won: true/false\r\n    }\r\n*/\r\n/**\r\n * \r\n * @param {object} data The returned data object\r\n * @param {object} gameObj The game object\r\n */\r\n\r\nexport const AnalyzeCastle = ( data, gameObj ) => {\r\n\r\n    const record = {\r\n        id: gameObj.id, \r\n        color: gameObj.color, \r\n        won: (gameObj.result === \"win\") ? true : false,\r\n        date: gameObj.date,\r\n        castled: false,\r\n        ply: -1,\r\n        plyPercent: -1,\r\n        phase: \"NA\",\r\n    }\r\n\r\n    let plyCastled = data?.castled[gameObj.color];\r\n\r\n    if(plyCastled === undefined || plyCastled === null || !(typeof(plyCastled) === \"number\")) {\r\n        console.warn({\r\n            message: \"Ply castled is undefined (data.castled[gameObj.color])\",\r\n            id: gameObj.id,\r\n            color: gameObj.color,\r\n            plyCastled: plyCastled\r\n        })\r\n        return;\r\n    }\r\n\r\n    if(plyCastled != -1) { // -1 means did not castle\r\n        plyCastled++;   // correct for TRUE ply (data starts @ 0 when should start at 1)\r\n\r\n        record.castled = true;\r\n        record.ply = plyCastled;\r\n        record.plyPercent = plyPercent(plyCastled, data.totalPositions)\r\n        record.phase = phase(plyCastled, data.gamePhases);\r\n    }\r\n\r\n    store.getState().addCastled(record);\r\n    \r\n    // console.log(store.getState().castled);\r\n}\r\n\r\n\r\n/**\r\n * \r\n * @param {string} type \"inaccuracy, mistake, blunder\"\r\n * @param {object} data the analysis object\r\n * @param {object} gameObj the game object\r\n */\r\nexport const AnalyzeClassification = (type, data, gameObj) => {\r\n    // constants\r\n\tconst allowed = [\"blunder\", \"mistake\", \"inaccuracy\"];\r\n    const p = data?.positions;\r\n    const totalType = data?.tallies?.report?.[gameObj.color]?.[type];\r\n    \r\n    // input validation\r\n    if(!allowed.includes(type)) {\r\n        throw {\r\n            message: \"invalid move type\",\r\n            type: type\r\n        }\r\n    }\r\n\r\n    if(p === undefined || p === null || !p) {\r\n        console.warn({\r\n            message: \"positions is undefined\",\r\n            id: gameObj.id,\r\n            color: gameObj.color,\r\n            p: p\r\n        })\r\n        return;\r\n    }\r\n    if(totalType === undefined || totalType === null || !(typeof(totalType) === \"number\")) {\r\n        console.warn({\r\n            message: \"totalType is undefined\",\r\n            id: gameObj.id,\r\n            color: gameObj.color,\r\n            totalType: totalType\r\n        })\r\n        return;\r\n    }\r\n    \r\n\r\n    let count = 0;\r\n    let i = (p[0].color === gameObj.color) ? 0 : 1;\r\n\r\n    const recordProto = {   // perhaps extract this to a different file?\r\n        id: gameObj.id, \r\n        color: gameObj.color, \r\n        won: (gameObj.result === \"win\") ? true : false,\r\n        date: gameObj.date,\r\n        eco: data.book.code,\r\n        score: NaN,\r\n        difference: NaN,\r\n        scenarios: {},\r\n        ply: -1,\r\n        plyPercent: -1,\r\n        phase: \"NA\",\r\n        timeSpent: -1,\r\n        timeToThink: -1,\r\n        timeToThinkPercent: -1\r\n    }\r\n\r\n    if(totalType !== 0) {\r\n\r\n        while(count < totalType && i <= data.totalPositions - 2) {\r\n            if(p[i].classificationName === type) {\r\n                let record = {...recordProto, scenarios: {...recordProto.scenarios}};\r\n\r\n                // console.log(\"index: \", i, p[i], record)\r\n                record.score = p[i].playedMove.score;\r\n                record.difference = p[i].difference;\r\n                record.scenarios = p[i].scenarios;\r\n\r\n                record.ply = i + 1; // starts @ 0 so increment\r\n                record.plyPercent = plyPercent(record.ply, data.totalPositions)\r\n                record.phase = phase(record.ply, data.gamePhases);\r\n\r\n                if(data.time) {\r\n                    // console.log(\"id: \", gameObj.id, data)\r\n                    record.timeSpent = data.time.moves[i] / 10;\r\n                    record.timeToThink = calculateClockTime(data.time.moves, i, gameObj.timecontrol);\r\n                    record.timeToThinkPercent = record.timeToThink / totalFromTC(gameObj.timecontrol) * 100\r\n                }\r\n                // **************************** COME BACK AND CHECK THIS\r\n                // record.takeaway = {\r\n                //     type: data.TEP.takeaways[i]?.[0].type, // need to check\r\n                // }\r\n\r\n                // console.log(record);\r\n                store.getState().addMoveType(type, record);\r\n                count++;\r\n            }\r\n            i += 2;\r\n        }\r\n    }\r\n\r\n    // console.log(store.getState()[type])\r\n}\r\n\r\n// * openings {\r\n//     * \t id: gameid\r\n//     *   won: true/false\r\n//     *   caps: score\r\n//     *   date: dateplayed\r\n//     *   eco: eco // might be extraneous\r\n//     *   numberbookply: x\r\n//     *   \r\n//     *   \r\n//     * }\r\n/**\r\n * \r\n * @param {object} data The returned data object\r\n * @param {object} gameObj The game object\r\n */\r\nexport const AnalyzeOpenings = (data, gameObj) => {\r\n    if(data?.book === undefined) {\r\n        console.warn(`data.book undefined for ${gameObj.id} ${gameObj.color}`)\r\n    }\r\n    if(data?.bookPly === undefined) {\r\n        console.warn(`data.book undefined for ${gameObj.id} ${gameObj.color}`)\r\n    }\r\n\r\n    if(data?.CAPS?.[gameObj.color]?.all === undefined) {\r\n        console.warn(`data.CAPS is undefined for ${gameObj.id} ${gameObj.color}`)\r\n    }\r\n\r\n    const record = {\r\n        id: gameObj.id, \r\n        color: gameObj.color, \r\n        won: (gameObj.result === \"win\") ? true : false,\r\n        date: gameObj.date,\r\n        caps: data?.CAPS?.[gameObj.color]?.all,\r\n        eco: data?.book?.code,\r\n        name: data?.book?.name,\r\n        bookPly: data?.bookPly,\r\n    }\r\n\r\n    store.getState().addOpening(record);\r\n    // console.log(store.getState().opening);\r\n}\r\n\r\n/*\r\n    pattern {\r\n        id:\r\n        won:\r\n        color:\r\n        [patternName]: {\r\n            #ply:\r\n            plyPercent:\r\n            phase: [beg, mid, end]\r\n        }\r\n    }\r\n*/\r\n/**\r\n * \r\n * @param {object} data The analysis data\r\n * @param {object} gameObj the game object\r\n */\r\nexport const AnalyzeGamePatterns = (data, gameObj) => {\r\n    let record = {\r\n        id: gameObj.id, \r\n        color: gameObj.color, \r\n        won: (gameObj.result === \"win\") ? true : false,\r\n        eco: data.book.code,\r\n        date: gameObj.date,\r\n    }\r\n\r\n\r\n    const d = data?.TEP?.moves?.[gameObj.color] // rename to make easier to work with\r\n\r\n    if(d === undefined || d === null || !d) {\r\n        console.warn({\r\n            message: \"data.TEP.moves[gameObj.color] is undefined\",\r\n            id: gameObj.id,\r\n            color: gameObj.color\r\n        })\r\n        return;\r\n    }\r\n\r\n    for(const i in d) {     // \r\n\r\n        let p = new Array();\r\n        for(const j of d[i]) {\r\n            let phs = phase(j, data.gamePhases);\r\n            if(!p.includes(phs)) { p.push(phs); }\r\n\r\n            if(p.length === 3) break;   // shortcircuit if already complete\r\n\r\n            // console.log(j, data.gamePhases, phs)\r\n        }\r\n\r\n        // let record = {...recordProto};\r\n        record[i] = {\r\n            plyPresent: i.length,\r\n            PercentPresent: plyPercent(i.length, data.totalPositions),\r\n            phase: p\r\n        }\r\n    }\r\n\r\n    store.getState().addGamePattern(record)\r\n    // console.log(store.getState().gamePatterns)\r\n}\r\n\r\n/*\r\nconst tacticProto = {\r\n    id: gameObj.id, \r\n    type: {}, \r\n    name: \"NA\",\r\n    color: gameObj.color, \r\n    won: (gameObj.result === \"win\") ? true : false,\r\n    date: gameObj.date,\r\n    eco: data.book.code,\r\n    eval: {},\r\n    scenarios: {},\r\n    ply: -1,\r\n    plyPercent: -1,\r\n    phase: \"NA\",\r\n    timeSpent: -1,\r\n    timeToThink: -1,\r\n    timeToThinkPercent: -1,\r\n    class: \"NA\",\r\n}\r\n*/\r\n// const getName\r\nexport const AnalyzeAllTactics2 = (data, gameObj) => {\r\n    const KnownTacticsTypes = [\r\n        \"fork\", \"mate\",\"material left undefended\",\r\n        \"undefended material\",\"pin\",\"trapped piece\",\r\n        \"under-defended material\", \"winning exchange\",\r\n        \"skewer\"\r\n    ];\r\n\r\n    const tacticProto = {\r\n        id: gameObj.id, \r\n        color: gameObj.color, \r\n        won: (gameObj.result === \"win\") ? true : false,\r\n        eco: data.book.code,\r\n        date: gameObj.date,\r\n        type: {\r\n            name: \"NA\",\r\n            type: \"NA\",\r\n            group: \"NA\"\r\n        }, \r\n        eval: {},\r\n        scenarios: {},\r\n        ply: -1,\r\n        plyPercent: -1,\r\n        phase: \"NA\",\r\n        timeSpent: -1,\r\n        timeToThink: -1,\r\n        timeToThinkPercent: -1,\r\n        class: \"NA\",\r\n    }\r\n\r\n    const p = data?.positions;\r\n    const t = data?.TEP?.takeaways;\r\n\r\n    if(p === undefined || p === null || !p) {\r\n        console.warn({\r\n            message: \"positions is undefined\",\r\n            id: gameObj.id,\r\n            color: gameObj.color,\r\n            p: p\r\n        })\r\n        return;\r\n    }\r\n\r\n    if(t === undefined || t === null || !t) {\r\n        console.warn({\r\n            message: \"takeaways is undefined\",\r\n            id: gameObj.id,\r\n            color: gameObj.color,\r\n            t: t\r\n        })\r\n        return;\r\n    }\r\n\r\n    for(let i in t) {\r\n        i = Number(i)\r\n\r\n        for(let j = 0; j < t[i].length; j++) {\r\n            const ele = t[i]?.[j]\r\n\r\n            // console.log(t, t.i, i, typeof(i), ele, ele?.color)\r\n            if (ele?.color === gameObj.color) {\r\n                // console.log(ele.type)\r\n\r\n                // warn if type is not in the known array\r\n                if(!KnownTacticsTypes.some((e) => SameTacticType(ele.type, e))) {\r\n                    console.warn(\"Not included\", ele.type, gameObj.id) // if gets here then it is a new type of tactic\r\n                }\r\n\r\n                else {\r\n                    console.warn(ele.type)\r\n\r\n                    let record = {...tacticProto,};\r\n\r\n                    // console.log(\"index: \", i, p[i], record)\r\n                    record.type = {\r\n                        type: ele.type,\r\n                        group: ele.group\r\n                    }\r\n                    // record.type.\r\n                    // console.log(ele.type, ele.group)\r\n\r\n                    record.eval = {\r\n                        scoreAfter: p[i - 1].playedMove.score,\r\n                        difference: p[i - 1].difference\r\n                    }\r\n\r\n                    record.scenarios = p[i - 1].scenarios;\r\n\r\n                    record.ply = i; // the actual game ply\r\n                    record.plyPercent = plyPercent(record.ply, data.totalPositions)\r\n                    record.phase = phase(record.ply, data.gamePhases);\r\n        \r\n                    if(data.time) {\r\n                        record.timeSpent = data.time.moves[i - 1] / 10;\r\n                        record.timeToThink = calculateClockTime(data.time.moves, i - 1, gameObj.timecontrol);\r\n                        record.timeToThinkPercent = record.timeToThink / totalFromTC(gameObj.timecontrol) * 100\r\n                    } else {\r\n                        console.log(\"id: \", gameObj.id, data)\r\n                    }\r\n                    record.class = ele.class;\r\n        \r\n                    UpdateTacticsState(ele.type, record);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/*\r\n    tactictype {\r\n        id\r\n        color\r\n        won\r\n        date\r\n        ply\r\n        plypercent\r\n        timeSpent\r\n        time2think\r\n        t2t%\r\n        phase\r\n        spotted\r\n        fen - eventually\r\n        class - (blunder/missed)\r\n\r\n    }\r\n*/\r\n// export const AnalyzeAllTactics = (data, gameObj) => {\r\n//     AnalyzeTactics(\"fork\", data, gameObj);\r\n//     AnalyzeTactics(\"mate\", data, gameObj);\r\n//     AnalyzeTactics(\"material left undefended\", data, gameObj)\r\n//     AnalyzeTactics(\"undefended material\", data, gameObj)\r\n//     AnalyzeTactics(\"pin\", data, gameObj)\r\n//     AnalyzeTactics(\"trapped piece\", data, gameObj)\r\n\r\n//     console.log(\r\n//         store.getState().fork, \r\n//         store.getState().mate,\r\n//         store.getState().hanging,\r\n//         store.getState().relativePin,\r\n//         store.getState().absolutePin,\r\n//         store.getState().trapped\r\n//     )\r\n// }\r\n\r\n/*\r\nexport const AnalyzeTactics = (name, data, gameObj) => {\r\n    const tacticProto = {\r\n        id: gameObj.id, \r\n        type: {\r\n            name: name,\r\n            type: \"NA\",\r\n            group: \"NA\"\r\n        },\r\n        color: gameObj.color, \r\n        won: (gameObj.result === \"win\") ? true : false,\r\n        date: gameObj.date,\r\n        eco: data.book.code,\r\n        eval: {},\r\n        scenarios: {},\r\n        ply: -1,\r\n        plyPercent: -1,\r\n        phase: \"NA\",\r\n        timeSpent: -1,\r\n        timeToThink: -1,\r\n        timeToThinkPercent: -1,\r\n        class: \"NA\",\r\n    }\r\n\r\n    const p = data.positions;\r\n    const t = data.TEP.takeaways;\r\n\r\n    for(const i in t) {\r\n        // i = Number(i)\r\n\r\n        const ele = t[i]?.[0]\r\n        // console.log(t, t.i, i, typeof(i), ele, ele?.color)\r\n\r\n        if (ele?.color === gameObj.color) {\r\n            console.log(ele.type)\r\n\r\n            if(SameTacticType(ele.type,name)) {\r\n                let record = {...tacticProto};\r\n\r\n                // console.log(\"index: \", i, p[i], record)\r\n                record.type.type = ele.type;\r\n                record.type.group = ele.group;\r\n\r\n                record.eval = {\r\n                    scoreAfter: p[i - 1].playedMove.score,\r\n                    difference: p[i - 1].difference\r\n                }\r\n                record.scenarios = p[i - 1].scenarios;\r\n\r\n                record.ply = i; // the actual game ply\r\n                record.plyPercent = plyPercent(record.ply, data.totalPositions)\r\n                record.phase = phase(record.ply, data.gamePhases);\r\n    \r\n                record.timeSpent = data.time.moves[i - 1] / 10;\r\n                \r\n                record.timeToThink = calculateClockTime(data.time.moves, i - 1, gameObj.timecontrol);\r\n                record.timeToThinkPercent = record.timeToThink / totalFromTC(gameObj.timecontrol) * 100\r\n    \r\n                record.class = ele.class\r\n    \r\n                // console.log(record);\r\n                UpdateTacticsState(name, record);\r\n            }\r\n        }\r\n    }\r\n}\r\n*/\r\n\r\nexport const SameTacticType = (actual, user) => {\r\n    const regex = \"\\\\b\" + user + \"\\\\b\";\r\n    const index = actual.toLowerCase().search(new RegExp(regex))\r\n\r\n    // console.log(regex, actual, index)\r\n\r\n    if (index !== -1) {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n    // ele.type.toLowerCase().indexOf(new RegExp(\"\\b\" + name + \"\\b\",g)) !== -1\r\n}\r\n\r\n// in major need of a refactoring\r\nexport const UpdateTacticsState = (name, record) => {\r\n    name = name.toLowerCase();\r\n    // console.log(name)\r\n\r\n    if(SameTacticType(name, \"trapped piece\")) { \r\n        record.type.name = \"trapped\";\r\n        store.getState().addTactic(\"trapped\",record); return;\r\n    }\r\n\r\n    if(SameTacticType(name, \"skewer\")) { \r\n        record.type.name = \"skewer\";\r\n        store.getState().addTactic(\"skewer\",record); return;\r\n    }\r\n\r\n    if(SameTacticType(name,\"fork\")) {\r\n        // console.log(\"added fork\", record)\r\n        // console.log(record.type.type)\r\n        // console.log(re)\r\n        record.type.name = \"fork\"; \r\n        store.getState().addTactic(\"fork\", record); return; \r\n    }\r\n\r\n    if(SameTacticType(name,\"mate\") || SameTacticType(record.type.group, \"checkmate\")) { \r\n        record.type.name = \"mate\"; \r\n        store.getState().addTactic(\"mate\", record); return; \r\n    }\r\n    if(SameTacticType(name,\"material left undefended\") || SameTacticType(name, \"undefended material\")) { \r\n        // console.log(\"added hanging\", record)\r\n        record.type.name = \"hanging\";\r\n        store.getState().addTactic(\"hanging\", record); return; \r\n    }\r\n    \r\n\r\n    if(SameTacticType(name, \"under-defended material\")) {\r\n        record.type.name = \"underdefended\";\r\n        store.getState().addTactic(\"underdefended\", record); return;\r\n    }\r\n\r\n    if(SameTacticType(name, \"winning exchange\")) {\r\n        // console.log(\"adding winning exchange\")\r\n        record.type.name = \"winning exchange\";\r\n        store.getState().addTactic(\"winningExchange\", record); return;\r\n    }\r\n\r\n    if(name.includes(\"pin\")) { \r\n        if(record.type.group.includes(\"relative\") || record.type.type.includes(\"relative\")) {\r\n            record.type.name = \"relative pin\";\r\n            store.getState().addTactic(\"relativePin\", record); return; \r\n        }\r\n        record.type.name = \"absolute pin\";\r\n        store.getState().addTactic(\"absolutePin\", record); return; \r\n    }\r\n}\r\n",{"ruleId":"85","severity":1,"message":"86","line":4,"column":10,"nodeType":"87","messageId":"88","endLine":4,"endColumn":18},{"ruleId":"89","replacedBy":"90"},{"ruleId":"91","replacedBy":"92"},{"ruleId":"85","severity":1,"message":"93","line":3,"column":8,"nodeType":"87","messageId":"88","endLine":3,"endColumn":16},{"ruleId":"85","severity":1,"message":"94","line":12,"column":22,"nodeType":"87","messageId":"88","endLine":12,"endColumn":36},{"ruleId":"85","severity":1,"message":"95","line":12,"column":10,"nodeType":"87","messageId":"88","endLine":12,"endColumn":17},{"ruleId":"96","severity":1,"message":"97","line":84,"column":12,"nodeType":"98","messageId":"99","endLine":109,"endColumn":7},{"ruleId":"100","severity":1,"message":"101","line":31,"column":3,"nodeType":"102","messageId":"103","endLine":34,"endColumn":4},{"ruleId":"100","severity":1,"message":"101","line":54,"column":3,"nodeType":"102","messageId":"103","endLine":59,"endColumn":4},{"ruleId":"100","severity":1,"message":"101","line":83,"column":3,"nodeType":"102","messageId":"103","endLine":86,"endColumn":4},{"ruleId":"85","severity":1,"message":"104","line":2,"column":10,"nodeType":"87","messageId":"88","endLine":2,"endColumn":15},{"ruleId":"85","severity":1,"message":"105","line":1,"column":23,"nodeType":"87","messageId":"88","endLine":1,"endColumn":28},{"ruleId":"85","severity":1,"message":"106","line":1,"column":30,"nodeType":"87","messageId":"88","endLine":1,"endColumn":40},{"ruleId":"85","severity":1,"message":"104","line":2,"column":10,"nodeType":"87","messageId":"88","endLine":2,"endColumn":15},{"ruleId":"100","severity":1,"message":"101","line":24,"column":9,"nodeType":"102","messageId":"103","endLine":28,"endColumn":10},{"ruleId":"100","severity":1,"message":"101","line":14,"column":9,"nodeType":"102","messageId":"103","endLine":18,"endColumn":10},{"ruleId":"100","severity":1,"message":"101","line":43,"column":25,"nodeType":"102","messageId":"103","endLine":46,"endColumn":26},{"ruleId":"100","severity":1,"message":"101","line":79,"column":9,"nodeType":"102","messageId":"103","endLine":83,"endColumn":10},{"ruleId":"107","severity":1,"message":"108","line":107,"column":9,"nodeType":"109","messageId":"110","endLine":107,"endColumn":27},{"ruleId":"100","severity":1,"message":"101","line":108,"column":9,"nodeType":"102","messageId":"103","endLine":112,"endColumn":10},{"ruleId":"107","severity":1,"message":"108","line":126,"column":8,"nodeType":"109","messageId":"110","endLine":126,"endColumn":19},{"ruleId":"100","severity":1,"message":"101","line":127,"column":9,"nodeType":"102","messageId":"103","endLine":130,"endColumn":10},{"ruleId":"107","severity":1,"message":"108","line":152,"column":8,"nodeType":"109","messageId":"110","endLine":152,"endColumn":19},{"ruleId":"107","severity":1,"message":"108","line":152,"column":23,"nodeType":"109","messageId":"110","endLine":152,"endColumn":36},{"ruleId":"100","severity":1,"message":"101","line":153,"column":9,"nodeType":"102","messageId":"103","endLine":157,"endColumn":10},{"ruleId":"100","severity":1,"message":"101","line":159,"column":9,"nodeType":"102","messageId":"103","endLine":163,"endColumn":10},{"ruleId":"107","severity":1,"message":"108","line":203,"column":8,"nodeType":"109","messageId":"110","endLine":203,"endColumn":21},{"ruleId":"100","severity":1,"message":"101","line":204,"column":9,"nodeType":"102","messageId":"103","endLine":208,"endColumn":10},{"ruleId":"89","replacedBy":"111"},{"ruleId":"91","replacedBy":"112"},{"ruleId":"113","severity":1,"message":"114","line":46,"column":19,"nodeType":"109","messageId":"115","endLine":46,"endColumn":21},{"ruleId":"100","severity":1,"message":"101","line":75,"column":9,"nodeType":"102","messageId":"103","endLine":78,"endColumn":10},{"ruleId":"116","severity":1,"message":"117","line":240,"column":17,"nodeType":"118","messageId":"119","endLine":240,"endColumn":28},"no-unused-vars","'Provider' is defined but never used.","Identifier","unusedVar","no-native-reassign",["120"],"no-negated-in-lhs",["121"],"'LoadForm' is defined but never used.","'setInitialized' is assigned a value but never used.","'Analyze' is defined but never used.","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'games', 'games', 'gamenum', 'games', 'games', 'games', 'games', 'games', 'games', 'games', 'gamenum'.","ArrowFunctionExpression","unsafeRefs","no-throw-literal","Expected an error object to be thrown.","ThrowStatement","object","'store' is defined but never used.","'phase' is defined but never used.","'plyPercent' is defined but never used.","use-isnan","Use the isNaN function to compare with NaN.","BinaryExpression","comparisonWithNaN",["120"],["121"],"eqeqeq","Expected '!==' and instead saw '!='.","unexpected","no-array-constructor","The array literal notation [] is preferable.","NewExpression","preferLiteral","no-global-assign","no-unsafe-negation"]